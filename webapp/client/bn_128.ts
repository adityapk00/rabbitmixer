// EC Math operations for BN_128 curve. Since there is no native library for JS that implements the bn_128 curve,
// we use the Parity's EVM implementation of BN_128 cross-compiled from rust to JS. Note that this is (I believe)
// provided by the parity team itself, so we're not actually mucking with it. 
import * as bn128Module         from "rustbn.js";
import * as createKeccakHash    from "keccak/js";

import {BigNumber}      from "bignumber.js"
import * as etherutil   from "ethereumjs-util";

class BN128 {
    public hexWithPad(num: BigNumber): string {
        var pad = "0000000000000000000000000000000000000000000000000000000000000000";
        return (pad + num.toString(16)).substr(-64);
    }

    /**
     * BN_128 EC point addition. 
     * @return {array} Array with 2 elements, representing point_x and point_y
     */
    public ecAdd (point_1x: BigNumber, point_1y: BigNumber, 
                        point_2x: BigNumber, point_2y: BigNumber): BigNumber[] {
        // First, we have to create the data. Note that the precompiles expect data as a single hex-encoded string, with 64 bytes per argument.
        // ECMul takes 3 arguments - pointx, pointy, and scalar while ECAdd takes 4 arguments - x,y for the 2 points. 
        var inputHexStr = "";
        inputHexStr     += this.hexWithPad(point_1x);
        inputHexStr     += this.hexWithPad(point_1y);
        inputHexStr     += this.hexWithPad(point_2x);
        inputHexStr     += this.hexWithPad(point_2y);

        var ecAddPrecompile = bn128Module.cwrap('ec_add', 'string', ['string'])
        let result = ecAddPrecompile(inputHexStr);
        return [new BigNumber(result.substr(0, 64), 16), new BigNumber(result.substr(64, 64), 16)];
    }

    /**
     * BN_128 EC point multiplication. 
     * @return {array} Array with 2 elements, representing point_x and point_y
     */
    public ecMul(point_1x: BigNumber, point_1y: BigNumber, scalar: BigNumber) : BigNumber[] {
        // First, we have to create the data. Note that the precompiles expect data as a single hex-encoded string, with 64 bytes per argument.
        // ECMul takes 3 arguments - pointx, pointy, and scalar while ECAdd takes 4 arguments - x,y for the 2 points. 
        var inputHexStr = "";
        inputHexStr     += this.hexWithPad(point_1x);
        inputHexStr     += this.hexWithPad(point_1y);
        inputHexStr     += this.hexWithPad(scalar);

        var ecMulPrecompile = bn128Module.cwrap('ec_mul', 'string', ['string'])
        var result = ecMulPrecompile(inputHexStr);
        return [new BigNumber(result.substr(0, 64), 16), new BigNumber(result.substr(64, 64), 16)]
    }

    public G = [new BigNumber("1"), new BigNumber("2")]; // Generator point
    public H = [new BigNumber("17856212038068422348937662473302114032147350344021172871924595963388108456668"), 
                new BigNumber("21295818415838735026194046494954432012836335667085206402831343127503290780315")];
    public curveN = new BigNumber("30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001", 16);
    public curveP = new BigNumber("30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47", 16);
            
    public privateKeyToPubkey(pk: Buffer): BigNumber[] {
        // Pubkey is the point generated by pk * G, where G is the curve's generator function. 
        return this.ecMul(this.G[0], this.G[1], new BigNumber(pk.toString("hex"), 16));
    }

    public BufferFromBigNumber(v: BigNumber): Buffer {
        var hex = v.toString(16);
        if (hex.length % 2 == 1) {
            hex = "0" + hex;
        }
        return new Buffer(hex, "hex");
    }

    public BigNumberFromBuffer(b: Buffer): BigNumber {
        return new BigNumber(b.toString("hex"), 16);
    }
    

    public ecdh(pk: Buffer, other_pub: BigNumber[]): Buffer {
        var secret = this.ecMul(other_pub[0], other_pub[1], new BigNumber(pk.toString("hex"), 16));

        // Hash everything together to get ecdh
        var hashed_secret: Buffer = etherutil.sha3(Buffer.concat([
            this.BufferFromBigNumber(secret[0]),
            this.BufferFromBigNumber(secret[1])
        ]));

        return hashed_secret;
    }

    public getPedersonCommitment(amount: BigNumber, blinding_factor: BigNumber) {
        var T_amt               = this.ecMul(this.H[0], this.H[1], amount);
        var T_blinding          = this.ecMul(this.G[0], this.G[1], blinding_factor);
        var T                   = this.ecAdd(T_amt[0], T_amt[1], T_blinding[0], T_blinding[1]);

        return T;
    }

    public modN(num: BigNumber): BigNumber {
        while (num.isNegative()) {
            num = this.curveN.plus(num);
        }

        return num.mod(this.curveN);
    }

    public keccak256(buffer) {
        return createKeccakHash("keccak256").update(buffer).digest();
    }
    
};

export var bn128 = new BN128();